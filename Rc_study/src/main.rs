use crate::List::{Cons, Nil};
fn main() {
    // println!("Hello, world!");
    // 指针 一个变量在内存中包含的一个地址。（指向其它数据）
    // Rust中最常见的指针就是引用

    // 引用
    //  使用 &
    //  借用它指向的值

    // 没有其余的开销
    // 最常见的指针类型

    // 智能指针
    // 行为和指针相似
    // 有额外的元数据和功能

    // 引用计数智能指针类型
    // 通过记录所有者的数量，使一份数据被多个所有者同时持有
    // 并在没有任何所有者时自动清理数据

    // 引用： 只借用数据
    // 智能指针： 很多时候都拥有它所指向的数据

    // 智能指针的例子
    // String 和 Vec<T>
    // 都拥有一片内存区域，且允许用户对其操作
    // 还有元数据 （例如容量）
    // 提供额外的功能或保障(String 保障其数据是合并的UTF-8编码)

    // 智能指针的实现
    // 智能指针通常使用struct实现，并且实现了
    //  Deref和Drop 这两个 Trait

    // Deref Trait：允许智能指针struct的实例像引用一样使用，能够编写出同时适用
    // 智能指针和引用的代码

    // Drop Trait： 允许你自定义当智能指针实例走出作用域时的代码

    // 介绍标准库中常见的智能指针

    // Box<T> : 在heap内存上分配值
    // Rc<T>: 启用多重所有权的引用计数类型
    // Ref<T>和RefMut<T>, 通过RefCell<T>访问: 在运行时而不是编译时强制借用规则的类型

    // 内部可变模式, 不可变类型暴露出可修改其内部值的API
    // 引用循环: 它们如何泄露内存，已经如何防止其发生

    // Box<T>
    // 最简单的智能指针，允许你在heap(堆)上存储数据，而不是stack
    // stack上是指向heap的数据的指针
    // 没有其他的性能开销
    // 没有其他的额外的功能

    // 为什么是智能指针
    // 实现了Deref trait 和Drop trait

    // 常用场景
    // 在编译的时候，某类型的大小无法确定。但使用该类型的时候，上下文却需要知道它
    // 的确切大小
    // 或者你有大量数据，想移交所有权，但需要确保在操作时数据不会被复制
    // 第三种场景 使用某个值时，你只关心它是否实现了特定的trait，而不关心它的具体类型
    // let b = Box::new(5);
    // // 当b走到下面}下面之后会释放stack的指针和heap上面的数据
    // println!("b={}", b);

    // 使用Box赋能递归类型
    // 在编译的时候，Rust需要知道一个类型所占的空间大小
    // rust无法计算出递归类型在编译时的大小

    // 但Box类型能解决

    // Conslist

    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}

// 因为Box<T>是一个指针，Rust知道它需要多少空间，因为
// 指针的大小不会基于它指向的数据的大小变化而变化

// Box<T>只提供了 间接 存储和heap内存分配的功能
// 适用于间接的存储
enum List {
    Cons(i32, Box<List>),
    Nil,
}

// Rust 如何确定非递归类型的大小

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
}

// 上面枚举类型每个时刻最多一个变体，所以取最大的变体的空间就行
